/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                             avtGraviTPlot.C                                 //
// ************************************************************************* //

#include <avtGraviTPlot.h>

#include <avtGraviTFilter.h>

// GRAVIT includes

#include <View3DAttributes.h>
#include <WindowAttributes.h>
#include <LightList.h>
#include <LightAttributes.h>
#include <ColorAttribute.h>
#include <avtDatabase.h>
#include <avtCallback.h>
#include <avtDatabaseMetaData.h>
#include <vtkCellData.h>
#include <vtkDataSet.h>
#include <vtkPointSet.h>
#include <vtkImageData.h>
#include <vtkPolyData.h>
#include <vtkCellArray.h>
#include <vtkSmartPointer.h>
#include <avtIntervalTree.h>

#ifdef GRAVITADAPTER
#include <mpi.h>
#endif

avtDataObject_p hackyInput;

int avtGraviTFilter_LoadDomain(void * p, int domainId, double ** points, int& numPoints, int ** edges, int& numEdges )
{
   avtGraviTFilter * in = (avtGraviTFilter*)p; 

   return in->LoadDomain( domainId, points, numPoints, edges, numEdges);
   
}

// ****************************************************************************
//  Method: avtGraviTPlot constructor
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************
class avtGraviTRenderer : public avtCustomRenderer
{
 virtual void Render(vtkDataSet * ds){}; 
};
avtGraviTPlot::avtGraviTPlot()
{
    graviTFilter = new avtGraviTFilter();
    ref_ptr<avtGraviTRenderer> renderer =  new avtGraviTRenderer;

    avtCustomRenderer_p cr;
    CopyTo(cr, renderer);
    mapper = new avtUserDefinedMapper(cr);
#ifdef GRAVITADAPTER
    adapter = new VisitAdapter;
    std::cerr<<"definition defined"<<std::endl;
#else
    std::cerr<<"definition not defined"<<std::endl;
#endif
}


// ****************************************************************************
//  Method: avtGraviTPlot destructor
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtGraviTPlot::~avtGraviTPlot()
{
    if (mapper != NULL)
    {
        delete mapper;
        mapper = NULL;
    }

    if (graviTFilter != NULL)
    {
        delete graviTFilter;
        graviTFilter = NULL;
    }
#ifdef GRAVITADAPTER
    if (adapter != NULL)
    {
        delete adapter;
        adapter = NULL;
    }
#endif
}


// ****************************************************************************
//  Method:  avtGraviTPlot::Create
//
//  Purpose:
//    Call the constructor.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtPlot*
avtGraviTPlot::Create()
{
    return new avtGraviTPlot;
}

// ****************************************************************************
//  Method: avtGraviTPlot::GetMapper
//
//  Purpose:
//      Gets a mapper for this plot, it is actually a variable mapper.
//
//  Returns:    The variable mapper typed as its base class mapper.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtMapper *
avtGraviTPlot::GetMapper(void)
{
    return mapper;
}


// ****************************************************************************
//  Method: avtGraviTPlot::ApplyOperators
//
//  Purpose:
//      Applies the operators associated with a GraviT plot.  
//      The output from this method is a query-able object.
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the GraviT plot has been applied.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtDataObject_p
avtGraviTPlot::ApplyOperators(avtDataObject_p input)
{
    return input;
}


// ****************************************************************************
//  Method: avtGraviTPlot::ApplyRenderingTransformation
//
//  Purpose:
//      Applies the rendering transformation associated with a GraviT plot.  
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the GraviT plot has been applied.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtDataObject_p
avtGraviTPlot::ApplyRenderingTransformation(avtDataObject_p input)
{   
    graviTFilter->SetInput(input);
    /* ------------------------ Check Scheduler    ------------------------*/

    // Check to see if the scheduler has changed
    if(progConfig.scheduler != atts.GetScheduleType())
    {
        progConfig.dataLoaded = false;
    }
    // Check the Scheduler Type

    progConfig.scheduler = atts.GetScheduleType();

    // Verify Scheduler Type is valid
    bool hasExtents = graviTFilter->HasExtents();

    if(progConfig.scheduler == GraviTAttributes::Image)
    {
        if(!hasExtents) progConfig.scheduler = GraviTAttributes::Domain;
    }
    else if(progConfig.scheduler == GraviTAttributes::Domain)
    {
        // this is OK, Domain mode supports both bounding boxes as well as just loading data.
    }
    else
    {
        //TODO: debug message here
    }

    bool filterOperateOnDemand = (progConfig.scheduler == GraviTAttributes::Image)? true:false;
    graviTFilter->SetFilterOperatingOnDemand(filterOperateOnDemand);

    hackyInput = input;
    progConfig.dataLoaded = false;
    return graviTFilter->GetOutput();
}


// ****************************************************************************
//  Method: avtGraviTPlot::CustomizeBehavior
//
//  Purpose:
//      Customizes the behavior as appropriate for a GraviT plot.  This includes
//      behavior like shifting towards or away from the screen.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

void
avtGraviTPlot::CustomizeBehavior(void)
{
    //behavior->SetShiftFactor(0.6);
}


// ****************************************************************************
//  Method: avtGraviTPlot::CustomizeMapper
//
//  Purpose:
//      A hook from the base class that allows the plot to change its mapper
//      based on the dataset input. 
//
//  Arguments:
//      doi     The data object information.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************
void
avtGraviTPlot::CustomizeMapper(avtDataObjectInformation &doi)
{
/* Example of usage.
    int dim = doi.GetAttributes().GetCurrentSpatialDimension();
    if (dim == 2)
    {
    }
    else
    {
    }
 */
}

avtImage_p
avtGraviTPlot::ImageExecute(avtImage_p input, const WindowAttributes &window_atts)
{   
#ifdef GRAVITADAPTER
    int rank,world_size;

    int flag;
    flag = 0;
    MPI_Initialized(&flag);

    if(flag)
    {
        MPI_Comm_rank (MPI_COMM_WORLD, &rank);  /* get current process id */
        MPI_Comm_size (MPI_COMM_WORLD, &world_size);    /* get number of processes */
    }
    else
    {
        rank = 0;
        world_size = 1;
    }

    /* ------------------------ GET ATTRIBUTE PARMS ------------------------*/
    //GraviTAttributes atts

    unsigned char * diffcolor = atts.GetDiffColor().GetColor();
    unsigned char * speccolor = atts.GetSpecColor().GetColor();

    int samples = atts.GetSamples();
    double jitterSize = atts.GetJitterSize();

    int maxReflections = atts.GetMaxReflections();

    VisitAdapter::RayTraceProperties rayTraceProps;
    rayTraceProps.maxDepth = maxReflections;
    rayTraceProps.raySamples = samples;
    rayTraceProps.windowJitterSize = jitterSize;

    adapter->SetRayTraceProperties(rayTraceProps);

    /* ------------------------ SET CAMERA CONFIG ------------------------*/
    int size[2];
    input->GetSize(size,size+1);

    progConfig.filmSize[0] = size[0];
    progConfig.filmSize[1] = size[1];

    View3DAttributes viewAttr = window_atts.GetView3D();

    double * viewNormal = viewAttr.GetViewNormal();
    double * focalPoint = viewAttr.GetFocus();
    double zoom = viewAttr.GetImageZoom();
    double fov = viewAttr.GetViewAngle();
    double * upVector  = viewAttr.GetViewUp();
    double parScale = viewAttr.GetParallelScale();

    adapter->SetCamera(size, focalPoint, upVector, viewNormal, parScale/zoom, fov);

    if(!progConfig.dataLoaded && progConfig.scheduler == GraviTAttributes::Domain)
    {
        // clean the previous mesh if any
        adapter->ResetMeshAndInstance();

        // use domain mode
        adapter->SetTraceMode(1);
        avtDataset *ds = (avtDataset *) *hackyInput;
        avtIntervalTree * extents = ds->CalculateSpatialIntervalTree(true);
        int numBoundingBox = extents->GetNLeaves();

        int numLocalData = -1;
        vtkDataSet ** dataSets = ds->dataTree->GetAllLeaves(numLocalData);

        std::vector<int> domainIds;
        ds->dataTree->GetAllDomainIds(domainIds);

        adapter->SetTotalInstances(numBoundingBox);
        
        int domainIdIndex = 0;
        for(int lD = 0; lD < numBoundingBox; lD++)
        {   
            if(numLocalData > 0 && lD == domainIds[domainIdIndex])
            {
                vtkDataSet *ds2 = dataSets[domainIdIndex];

                vtkCellData * cellData = ds2->GetCellData();
                vtkPolyData * contourPD = (vtkPolyData *) ds2;
                int numPoints = contourPD->GetNumberOfPoints();
                vtkCellArray * allFaces = contourPD->GetPolys();
                // get the verts
                int contourSize = contourPD->GetNumberOfPoints();  
                
                double * points = new double[contourSize *3];

                for(vtkIdType i = 0; i < contourSize; i++)  
                {  
                    double vtkPts[3] = {0.0, 0.0, 0.0};  
                    contourPD->GetPoints()->GetPoint(i, vtkPts); 

                    points[i*3] = vtkPts[0];
                    points[i*3 +1] = vtkPts[1];
                    points[i*3 + 2] = vtkPts[2];
                }  

                vtkSmartPointer<vtkIdList> idList = vtkSmartPointer<vtkIdList>::New();
                allFaces->InitTraversal();  

                int totalEdges = allFaces->GetNumberOfCells();
                int * edges = new int[totalEdges * 3];

                for(int i = 0; i < totalEdges; i++)  
                {  
                    allFaces->GetNextCell(idList);  
                    int v1 = idList->GetId(0)+1;  
                    int v2 = idList->GetId(1)+1;  
                    int v3 = idList->GetId(2)+1;  

                    edges[i*3] = v1;
                    edges[i*3 + 1] = v2;
                    edges[i*3 + 2] = v3;   
                } 
        	
            	// Get material properties
                double materialColor[8] = {-1, -1, -1, -1, -1, -1, -1, -1}; 
            	atts.GetDiffColor().GetRgba(materialColor);
            	atts.GetSpecColor().GetRgba(materialColor+4);
            	int material = atts.GetMaterial();

            	adapter->SetData(points, contourSize, edges, totalEdges, material, materialColor);
                adapter->RegisterDomain(lD, rank);
        	
                delete [] edges;
                delete [] points;

                domainIdIndex++;
            }
            else // just insert the bounding box
            {                
                double bBox[6];
                extents->GetLeafExtents(lD, bBox);
                    
                double points[3*2];
                int totalPoints = 2;
                
                int *edges;
                int totalEdges = 0; // no need to set edges, just need points for the bb

                points[0 * 3 + 0]  = bBox[0];
                points[0 * 3 + 1]  = bBox[2];
                points[0 * 3 + 2]  = bBox[4];

                points[1 * 3 + 0]  = bBox[1];
                points[1 * 3 + 1]  = bBox[3];
                points[1 * 3 + 2]  = bBox[5];
         
                double materialColor[8] = {-1, -1, -1, -1, -1, -1, -1, -1}; 
                atts.GetDiffColor().GetRgba(materialColor);
                atts.GetSpecColor().GetRgba(materialColor+4);
                int material = atts.GetMaterial();

                adapter->SetBoundingBoxHolder(points, totalPoints, edges, totalEdges, material, materialColor);
            }   
        }

        progConfig.dataLoaded = true;
    }

    if(!progConfig.dataLoaded && progConfig.scheduler == GraviTAttributes::Image)
    {
        // clean the previous mesh if any
        adapter->ResetMeshAndInstance();

        /* ------------------------ SET CALLBACK FUNC ------------------------*/
        adapter->SetVisitProcessBlockFunc((void*)graviTFilter, avtGraviTFilter_LoadDomain);
        adapter->SetTraceMode(0);

        int numBoundingBoxes;
        double * lowers;
        double * uppers;
        graviTFilter->LoadBoundingBoxes(numBoundingBoxes, &lowers, &uppers);

        for(int i = 0; i < numBoundingBoxes; i++)
        {
            double * lower = lowers + 3*i;
            double * upper = uppers + 3*i;
            
            double points[3*2];
            int totalPoints = 2;
            
            int *edges;
            int totalEdges = 0; // Don't need to set any edges, just setting a dummy bounding box
            //TODO: write a custom empty bounding box function?

            points[0 * 3 + 0]  = lower[0];
            points[0 * 3 + 1]  = lower[1];
            points[0 * 3 + 2]  = lower[2];

            points[1 * 3 + 0]  = upper[0];
            points[1 * 3 + 1]  = upper[1];
            points[1 * 3 + 2]  = upper[2];
                
            double materialColor[8] = {-1, -1, -1, -1, -1, -1, -1, -1}; 
            atts.GetDiffColor().GetRgba(materialColor);
            atts.GetSpecColor().GetRgba(materialColor+4);
            int material = atts.GetMaterial();

            adapter->SetBoundingBoxHolder(points, totalPoints, edges, totalEdges, material, materialColor);
        }
        delete [] (uppers);
        delete [] (lowers);
        progConfig.dataLoaded = true;
    }

    /* ------------------------ GET LIGHTS ------------------------*/
    LightList lightList = window_atts.GetLights();

    int numLights = lightList.NumLights();

    std::vector<int> lightTypes;
    std::vector<double> lightDirection;
    std::vector<unsigned char> lightColor;
    std::vector<double> lightIntensity;

    int totalValidLights = 0;

    for(int i = 0; i < numLights; i++)
    {
        LightAttributes lightAttr = lightList.GetLight(i);

        // if(!lightAttr.GetEnabledFlagCanBeToggled())
        // {
        //     continue;
        // }

        if(lightAttr.GetEnabledFlag())
        {
            LightAttributes::LightType type = lightAttr.GetType();
            /*
            Ambient     
            Object  
            Camera  
            */

            totalValidLights++;

            double * direction = lightAttr.GetDirection();
            ColorAttribute colorAttr = lightAttr.GetColor();
            unsigned char * color = colorAttr.GetColor();
            double brightness =  lightAttr.GetBrightness();

            lightTypes.push_back((int)type);

            lightDirection.push_back(direction[0]);
            lightDirection.push_back(direction[1]);
            lightDirection.push_back(direction[2]);

            lightColor.push_back(color[0]);
            lightColor.push_back(color[1]);
            lightColor.push_back(color[2]);

            lightIntensity.push_back(brightness);
        }
    }

    adapter->SetLight(totalValidLights, lightTypes.data(), lightDirection.data(), lightColor.data(), lightIntensity.data());

    /* -------------------------MODIFY MATERIAL -------------*/
    double materialColor[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
    atts.GetDiffColor().GetRgba(materialColor);
    atts.GetSpecColor().GetRgba(materialColor+4);
    int material = atts.GetMaterial();
    adapter->ChangeMaterial(0, material, materialColor);

    /* ------------------------ DRAW ------------------------*/
    
    unsigned char * data = input->GetImage().GetRGBBuffer();

    adapter->Draw(data);
#endif
    avtImage_p rv = input;

    return rv;
}


// ****************************************************************************
//  Method: avtGraviTPlot::SetAtts
//
//  Purpose:
//      Sets the atts for the GraviT plot.
//
//  Arguments:
//      atts    The attributes for this GraviT plot.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

void
avtGraviTPlot::SetAtts(const AttributeGroup *a)
{
    const GraviTAttributes *newAtts = (const GraviTAttributes *)a;
    atts = *(GraviTAttributes *)newAtts;
}
