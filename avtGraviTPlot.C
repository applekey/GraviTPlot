/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                             avtGraviTPlot.C                                 //
// ************************************************************************* //

#include <avtGraviTPlot.h>

#include <avtGraviTFilter.h>

// GRAVIT includes

#include <View3DAttributes.h>
#include <WindowAttributes.h>
#include <LightList.h>
#include <LightAttributes.h>
#include <ColorAttribute.h>
#include <avtDatabase.h>
#include <avtCallback.h>
#include <avtDatabaseMetaData.h>
#include <vtkCellData.h>
#include <vtkDataSet.h>
#include <vtkPointSet.h>
#include <vtkImageData.h>
#include <vtkPolyData.h>
#include <vtkCellArray.h>
#include <vtkSmartPointer.h>
struct GravitProgramConfig
{
    // Camera Params
    double eyePoint[3];
    double focalPoint[3];
    double upVector[3];
    double view_direction[3];
    int filmSize[2];

    //Tracing Parms
    int maxDepth;
    int samples;
    unsigned char backgroundColor[3];
    bool dataLoaded;
    bool PreLoadData;
};


GravitProgramConfig hackyConfig;
avtDataObject_p hackyInput;

int avtGraviTFilter_LoadDomain(void * p, int domainId, double * points, int& numPoints, int * edges, int& numEdges )
{
   avtGraviTFilter * in = (avtGraviTFilter*)p; 

   return in->LoadDomain( domainId, points, numPoints, edges, numEdges);
   
}

// ****************************************************************************
//  Method: avtGraviTPlot constructor
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************
class avtGraviTRenderer : public avtCustomRenderer
{
 virtual void Render(vtkDataSet * ds){std::cerr<<"Render"<<std::endl;}; 
};
avtGraviTPlot::avtGraviTPlot()
{
    graviTFilter = new avtGraviTFilter();
    ref_ptr<avtGraviTRenderer> renderer =  new avtGraviTRenderer;

    avtCustomRenderer_p cr;
    CopyTo(cr, renderer);
    mapper = new avtUserDefinedMapper(cr);
}


// ****************************************************************************
//  Method: avtGraviTPlot destructor
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtGraviTPlot::~avtGraviTPlot()
{
    if (mapper != NULL)
    {
        delete mapper;
        mapper = NULL;
    }
    if (graviTFilter != NULL)
    {
        delete graviTFilter;
        graviTFilter = NULL;
    }
}


// ****************************************************************************
//  Method:  avtGraviTPlot::Create
//
//  Purpose:
//    Call the constructor.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtPlot*
avtGraviTPlot::Create()
{
    return new avtGraviTPlot;
}


// ****************************************************************************
//  Method: avtGraviTPlot::GetMapper
//
//  Purpose:
//      Gets a mapper for this plot, it is actually a variable mapper.
//
//  Returns:    The variable mapper typed as its base class mapper.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtMapper *
avtGraviTPlot::GetMapper(void)
{
    return mapper;
}


// ****************************************************************************
//  Method: avtGraviTPlot::ApplyOperators
//
//  Purpose:
//      Applies the operators associated with a GraviT plot.  
//      The output from this method is a query-able object.
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the GraviT plot has been applied.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtDataObject_p
avtGraviTPlot::ApplyOperators(avtDataObject_p input)
{
    return input;
    //std::cerr<<"apply operators"<<std::endl;
    //graviTFilter->SetInput(input);
    //return graviTFilter->GetOutput();
}


// ****************************************************************************
//  Method: avtGraviTPlot::ApplyRenderingTransformation
//
//  Purpose:
//      Applies the rendering transformation associated with a GraviT plot.  
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the GraviT plot has been applied.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

avtDataObject_p
avtGraviTPlot::ApplyRenderingTransformation(avtDataObject_p input)
{
    std::cerr<<"rendering transformation"<<std::endl;

    //graviTFilter->SetInput(input);
    hackyInput = input;
    hackyConfig.dataLoaded = false;
    hackyConfig.PreLoadData = true;
    return input;
    // avtDataObject_p x = graviTFilter->GetOutput();
    // return x;
}


// ****************************************************************************
//  Method: avtGraviTPlot::CustomizeBehavior
//
//  Purpose:
//      Customizes the behavior as appropriate for a GraviT plot.  This includes
//      behavior like shifting towards or away from the screen.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

void
avtGraviTPlot::CustomizeBehavior(void)
{
    //behavior->SetShiftFactor(0.6);
}


// ****************************************************************************
//  Method: avtGraviTPlot::CustomizeMapper
//
//  Purpose:
//      A hook from the base class that allows the plot to change its mapper
//      based on the dataset input. 
//
//  Arguments:
//      doi     The data object information.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************
void
avtGraviTPlot::CustomizeMapper(avtDataObjectInformation &doi)
{
/* Example of usage.
    int dim = doi.GetAttributes().GetCurrentSpatialDimension();
    if (dim == 2)
    {
    }
    else
    {
    }
 */
}

avtImage_p
avtGraviTPlot::ImageExecute(avtImage_p input, const WindowAttributes &window_atts)
{   
    std::cerr<<"In ImageExecute"<<std::endl;
    /* ------------------------ SET CALLBACK FUNC ------------------------*/

    adapter.SetVisitProcessBlockFunc((void*)graviTFilter,avtGraviTFilter_LoadDomain);
    
    /* ------------------------ GET ATTRIBUTE PARMS ------------------------*/

    //GraviTAttributes atts

    unsigned char * diffcolor = atts.GetDiffColor().GetColor();
    unsigned char * speccolor = atts.GetSpecColor().GetColor();

    //std::cerr<<color[0]<<" "<<color[1]<<" "<<color[2]<<std::endl;

    VisitAdapter::RayTraceProperties rayTraceProps;
    rayTraceProps.maxDepth = 2;
    rayTraceProps.raySamples = 3;
    rayTraceProps.windowJitterSize = 0.0;
    adapter.SetRayTraceProperties(rayTraceProps);


    /* ------------------------ SET CAMERA CONFIG ------------------------*/
    int size[2];
    input->GetSize(size,size+1);

    hackyConfig.filmSize[0] = size[0];
    hackyConfig.filmSize[1] = size[1];

    View3DAttributes viewAttr= window_atts.GetView3D();

    double * viewNormal = viewAttr.GetViewNormal();
    double * focalPoint = viewAttr.GetFocus();
    double zoom = viewAttr.GetImageZoom();
    double fov = viewAttr.GetViewAngle();
    double * upVector  = viewAttr.GetViewUp();
    double parScale = viewAttr.GetParallelScale();

    adapter.SetCamera(size,focalPoint, upVector, viewNormal, parScale/zoom, fov);


    /* ------------------------ GET LIGHTS ------------------------*/
    LightList lightList = window_atts.GetLights();

    int numLights = lightList.NumLights();

    std::vector<int> lightTypes;
    std::vector<double> lightDirection;
    std::vector<unsigned char> lightColor;
    std::vector<double> lightIntensity;

    int totalValidLights = 0;

    for(int i = 0;i <numLights;i++)
    {
        LightAttributes lightAttr = lightList.GetLight(i);

        // if(!lightAttr.GetEnabledFlagCanBeToggled())
        // {
        //     continue;
        // }

        if(lightAttr.GetEnabledFlag())
        {
            LightAttributes::LightType type = lightAttr.GetType();
            /*
            Ambient     
            Object  
            Camera  
            */

            totalValidLights++;

            double * direction = lightAttr.GetDirection();
            ColorAttribute colorAttr = lightAttr.GetColor();
            unsigned char * color = colorAttr.GetColor();
            double brightness =  lightAttr.GetBrightness();

            lightTypes.push_back((int)type);

            lightDirection.push_back(direction[0]);
            lightDirection.push_back(direction[1]);
            lightDirection.push_back(direction[2]);

            lightColor.push_back(color[0]);
            lightColor.push_back(color[1]);
            lightColor.push_back(color[2]);

            lightIntensity.push_back(brightness);

          //  std::cerr<<"Light Type:"<<type<<std::endl;
          //  std::cerr<<"Light Direction:"<<direction[0]<<" "<<direction[1]<<" "<<direction[2]<<std::endl;
          //  std::cerr<<"Light Color:"<<(unsigned int)color[0]<<" "<<(unsigned int)color[1]<<" "<<(unsigned int)color[2]<<std::endl;
          //  std::cerr<<"LightIntensity:"<<brightness<<std::endl;
        }
    }

  //  std::cerr<<"Total Valid Lights:"<<totalValidLights<<std::endl;

    adapter.SetLight(totalValidLights, lightTypes.data(), lightDirection.data(), lightColor.data(), lightIntensity.data());


    /* ------------------------ SET DATA CONFIG ------------------------*/

    // preLoadAllData
    if(!hackyConfig.dataLoaded && hackyConfig.PreLoadData)
    {

        avtDataset *ds = (avtDataset *) *hackyInput;
        vtkDataSet *ds2 = ds->dataTree->GetSingleLeaf();

        vtkCellData * cellData = ds2->GetCellData();
        vtkPolyData * contourPD = (vtkPolyData *) ds2;
        int numPoints = contourPD->GetNumberOfPoints();
        vtkCellArray * contourFaces = contourPD->GetPolys();
        // get the verts
        int contourSize = contourPD->GetNumberOfPoints();  
        
        double * points = new double[contourSize *3];

        for(vtkIdType i = 0; i < contourSize; i++)  
        {  
            double vtkPts[3] = {0.0,0.0,0.0};  
            contourPD->GetPoints()->GetPoint(i,vtkPts); 

            points[i*3] = vtkPts[0];
            points[i*3 +1] = vtkPts[1];
            points[i*3 + 2] = vtkPts[2];
        }  

        // link the edge

        vtkSmartPointer<vtkIdList> idList = vtkSmartPointer<vtkIdList>::New();
        contourFaces->InitTraversal();  

        int totalEdges = contourFaces->GetNumberOfCells();
        int * edges = new int[totalEdges * 3];

        for(int i = 0; i < totalEdges; i++)  
        {  
            contourFaces->GetNextCell(idList);  
            int v1 = idList->GetId(0)+1;  
            int v2 = idList->GetId(1)+1;  
            int v3 = idList->GetId(2)+1;  

            edges[i*3] = v1;
            edges[i*3 + 1] = v2;
            edges[i*3 + 2] = v3;   
        } 
	
    	// Get material properties
        double materialColor[8] = {-1,-1,-1,-1,-1,-1,-1,-1}; 
    	atts.GetDiffColor().GetRgba(materialColor);
    	atts.GetSpecColor().GetRgba(materialColor+4);
    	int material = atts.GetMaterial();

    	adapter.SetData(points, contourSize, edges, totalEdges, material, materialColor);
	
        delete [] edges;
        delete [] points;
        hackyConfig.dataLoaded = true;

    }

    if(!hackyConfig.PreLoadData)
    {
        // load the bounding boxes as skeleton mesh

        double lower[3] = {-1.0,-1.0,-1.0};
        double upper[3] = {-1.0,-1.0,-1.0};
        graviTFilter->LoadBoundingBoxes(lower, upper);

        
        double points[3*8];
        int totalPoints = 3*8;
        
        int *edges;
        int totalEdges = 0; // no need to set edges, just need points for the bb

        //souce http://answers.unity3d.com/questions/29797/how-to-get-8-vertices-from-bounds-properties.html
        points[0 * 3 + 0]  = lower[0];
        points[0 * 3 + 1]  = lower[1];
        points[0 * 3 + 2]  = lower[2];

        points[1 * 3 + 0]  = upper[0];
        points[1 * 3 + 1]  = upper[0];
        points[1 * 3 + 2]  = upper[0];

        //boundPoint1.x, boundPoint1.y, boundPoint2.z
        points[2 * 3 + 0]  = lower[0];
        points[2 * 3 + 1]  = lower[1];
        points[2 * 3 + 2]  = upper[2];

        //(boundPoint1.x, boundPoint2.y, boundPoint1.z);
        points[3 * 3 + 0]  = lower[0];
        points[3 * 3 + 1]  = upper[1];
        points[3 * 3 + 2]  = lower[2];

        //(boundPoint2.x, boundPoint1.y, boundPoint1.z);
        points[4 * 3 + 0]  = upper[0];
        points[4 * 3 + 1]  = lower[1];
        points[4 * 3 + 2]  = lower[2];

        //(boundPoint1.x, boundPoint2.y, boundPoint2.z);
        points[5 * 3 + 0]  = lower[0];
        points[5 * 3 + 1]  = upper[1];
        points[5 * 3 + 2]  = upper[2];

        //(boundPoint2.x, boundPoint1.y, boundPoint2.z);
        points[6 * 3 + 0]  = upper[0];
        points[6 * 3 + 1]  = lower[1];
        points[6 * 3 + 2]  = upper[2];

        //(boundPoint2.x, boundPoint2.y, boundPoint1.z);
        points[7 * 3 + 0]  = upper[0];
        points[7 * 3 + 1]  = upper[1];
        points[7 * 3 + 2]  = lower[2];

            
        double materialColor[8] = {-1,-1,-1,-1,-1,-1,-1,-1}; 
        atts.GetDiffColor().GetRgba(materialColor);
        atts.GetSpecColor().GetRgba(materialColor+4);
        int material = atts.GetMaterial();

        adapter.SetData(points, totalPoints, edges, totalEdges, material, materialColor);
        
    }

    /* ------------------------ DRAW ------------------------*/
    
    unsigned char * data = input->GetImage().GetRGBBuffer();

    adapter.Draw(data);
    avtImage_p rv = input;

    return rv;
}


// ****************************************************************************
//  Method: avtGraviTPlot::SetAtts
//
//  Purpose:
//      Sets the atts for the GraviT plot.
//
//  Arguments:
//      atts    The attributes for this GraviT plot.
//
//  Programmer: applekey -- generated by xml2avt
//  Creation:   Thu Apr 14 09:20:02 PDT 2016
//
// ****************************************************************************

void
avtGraviTPlot::SetAtts(const AttributeGroup *a)
{
    const GraviTAttributes *newAtts = (const GraviTAttributes *)a;
    atts = *(GraviTAttributes *)newAtts;
    
    //double materialColor[8];
    //newAtts->GetDiffColor().GetRgba(materialColor);
    //newAtts->GetSpecColor().GetRgba(materialColor+4);
    //int material = newAtts->GetMaterial();
    //std::cerr<<"Diffuse Color: "<<materialColor[0]<<" "<<materialColor[1]<<" "<<materialColor[2]<<std::endl;
    //std::cerr<<"Specular Color: "<<materialColor[4]<<" "<<materialColor[5]<<" "<<materialColor[6]<<std::endl;
    //std::cerr<<"Material: "<<material<<std::endl;
}
